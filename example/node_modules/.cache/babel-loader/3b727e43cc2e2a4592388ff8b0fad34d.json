{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport { getAssetUrlsFromId } from '@react-loosely-lazy/manifest';\nimport { getConfig } from '../config';\nimport { PHASE } from '../constants';\nimport { hash, displayNameFromId, isNodeEnvironment } from '../utils';\nimport { PRIORITY, RETRY_DELAY, RETRY_FACTOR } from './constants';\nimport { createComponentClient } from './components/client';\nimport { createComponentServer } from './components/server';\nimport { createDeferred } from './deferred';\nimport { preloadAsset } from './preload';\nimport { retry } from './retry';\nexport { PRIORITY };\nfunction lazyProxy(_loader, {\n  defer = PHASE.PAINT,\n  moduleId = '',\n  ssr = true\n} = {}) {\n  const isServer = isNodeEnvironment();\n  const dataLazyId = hash(moduleId);\n  const LazyInternal = isServer ? createComponentServer({\n    dataLazyId,\n    defer,\n    loader: _loader,\n    moduleId,\n    ssr\n  }) : createComponentClient({\n    dataLazyId,\n    defer,\n    // We separate the preload from the retryable request, as we do not want the preload to contribute to retry\n    // attempts, when the the loader fallback is used\n    deferred: createDeferred({\n      loader: () => {\n        const {\n          retry: maxAttempts\n        } = getConfig();\n        return retry(_loader, {\n          delay: RETRY_DELAY,\n          factor: RETRY_FACTOR,\n          maxAttempts\n        });\n      },\n      preload: _loader\n    }),\n    moduleId\n  });\n  LazyInternal.displayName = `Lazy(${displayNameFromId(moduleId)})`;\n  /**\n   * Allows getting module chunks urls\n   */\n\n  const getAssetUrls = () => {\n    const {\n      manifest\n    } = getConfig();\n    return getAssetUrlsFromId(manifest, moduleId);\n  };\n  /**\n   * Allows imperatively preload/ prefetch the module chunk asset\n   */\n\n  const preload = priority => {\n    const p = priority != null ? priority : defer === PHASE.PAINT ? PRIORITY.HIGH : PRIORITY.LOW;\n    return preloadAsset({\n      loader: _loader,\n      moduleId,\n      priority: p\n    });\n  };\n  return Object.assign(LazyInternal, {\n    getAssetUrls,\n    preload\n  });\n}\nexport const DEFAULT_OPTIONS = {\n  lazyForPaint: {\n    ssr: true,\n    defer: PHASE.PAINT\n  },\n  lazyAfterPaint: {\n    ssr: true,\n    defer: PHASE.AFTER_PAINT\n  },\n  lazy: {\n    ssr: false,\n    defer: PHASE.LAZY\n  }\n};\nexport function lazyForPaint(loader, opts) {\n  return lazyProxy(loader, _extends({}, DEFAULT_OPTIONS.lazyForPaint, opts || {}));\n}\nexport function lazyAfterPaint(loader, opts) {\n  return lazyProxy(loader, _extends({}, DEFAULT_OPTIONS.lazyAfterPaint, opts || {}));\n}\nexport function lazy(loader, opts) {\n  return lazyProxy(loader, _extends({}, DEFAULT_OPTIONS.lazy, opts || {}));\n}\nexport { isLoaderError } from './errors';","map":{"version":3,"names":["getAssetUrlsFromId","getConfig","PHASE","hash","displayNameFromId","isNodeEnvironment","PRIORITY","RETRY_DELAY","RETRY_FACTOR","createComponentClient","createComponentServer","createDeferred","preloadAsset","retry","lazyProxy","_loader","defer","PAINT","moduleId","ssr","isServer","dataLazyId","LazyInternal","loader","deferred","maxAttempts","delay","factor","preload","displayName","getAssetUrls","manifest","priority","p","HIGH","LOW","Object","assign","DEFAULT_OPTIONS","lazyForPaint","lazyAfterPaint","AFTER_PAINT","lazy","LAZY","opts","_extends","isLoaderError"],"sources":["../../../src/lazy/index.tsx"],"sourcesContent":["import { getAssetUrlsFromId } from '@react-loosely-lazy/manifest';\nimport { ComponentProps, ComponentType, FunctionComponent } from 'react';\n\nimport { getConfig } from '../config';\nimport { PHASE } from '../constants';\nimport { hash, displayNameFromId, isNodeEnvironment } from '../utils';\n\nimport { PRIORITY, RETRY_DELAY, RETRY_FACTOR } from './constants';\nimport { createComponentClient } from './components/client';\nimport { createComponentServer } from './components/server';\nimport { createDeferred } from './deferred';\nimport { ClientLoader, Loader, ServerLoader } from './loader';\nimport { preloadAsset } from './preload';\nimport { retry } from './retry';\nimport type { LazyOptions, LazyComponent, PreloadPriority } from './types';\n\nexport { PRIORITY };\nexport type { LazyOptions, LazyComponent };\n\nfunction lazyProxy<C extends ComponentType<any>>(\n  loader: Loader<C>,\n  { defer = PHASE.PAINT, moduleId = '', ssr = true }: LazyOptions = {}\n): LazyComponent<C> {\n  const isServer = isNodeEnvironment();\n  const dataLazyId = hash(moduleId);\n\n  const LazyInternal: FunctionComponent<ComponentProps<C>> = isServer\n    ? createComponentServer({\n        dataLazyId,\n        defer,\n        loader: loader as ServerLoader<C>,\n        moduleId,\n        ssr,\n      })\n    : createComponentClient({\n        dataLazyId,\n        defer,\n        // We separate the preload from the retryable request, as we do not want the preload to contribute to retry\n        // attempts, when the the loader fallback is used\n        deferred: createDeferred({\n          loader: () => {\n            const { retry: maxAttempts } = getConfig();\n\n            return retry(loader as ClientLoader<C>, {\n              delay: RETRY_DELAY,\n              factor: RETRY_FACTOR,\n              maxAttempts,\n            });\n          },\n          preload: loader as ClientLoader<C>,\n        }),\n        moduleId,\n      });\n\n  LazyInternal.displayName = `Lazy(${displayNameFromId(moduleId)})`;\n\n  /**\n   * Allows getting module chunks urls\n   */\n  const getAssetUrls = () => {\n    const { manifest } = getConfig();\n\n    return getAssetUrlsFromId(manifest, moduleId);\n  };\n\n  /**\n   * Allows imperatively preload/ prefetch the module chunk asset\n   */\n  const preload = (priority?: PreloadPriority) => {\n    const p =\n      priority ?? (defer === PHASE.PAINT ? PRIORITY.HIGH : PRIORITY.LOW);\n\n    return preloadAsset({ loader, moduleId, priority: p });\n  };\n\n  return Object.assign(LazyInternal, {\n    getAssetUrls,\n    preload,\n  });\n}\n\nexport const DEFAULT_OPTIONS: {\n  [key: string]: { ssr: boolean; defer: number };\n} = {\n  lazyForPaint: { ssr: true, defer: PHASE.PAINT },\n  lazyAfterPaint: { ssr: true, defer: PHASE.AFTER_PAINT },\n  lazy: { ssr: false, defer: PHASE.LAZY },\n};\n\nexport function lazyForPaint<C extends ComponentType<any>>(\n  loader: Loader<C>,\n  opts?: LazyOptions\n) {\n  return lazyProxy<C>(loader, {\n    ...DEFAULT_OPTIONS.lazyForPaint,\n    ...(opts || {}),\n  });\n}\n\nexport function lazyAfterPaint<C extends ComponentType<any>>(\n  loader: Loader<C>,\n  opts?: LazyOptions\n) {\n  return lazyProxy<C>(loader, {\n    ...DEFAULT_OPTIONS.lazyAfterPaint,\n    ...(opts || {}),\n  });\n}\n\nexport function lazy<C extends ComponentType<any>>(\n  loader: Loader<C>,\n  opts?: LazyOptions\n) {\n  return lazyProxy<C>(loader, {\n    ...DEFAULT_OPTIONS.lazy,\n    ...(opts || {}),\n  });\n}\n\nexport type { ClientLoader, Loader, ServerLoader };\nexport { isLoaderError } from './errors';\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}