{"ast":null,"code":"import React, { Component, Suspense, useLayoutEffect } from 'react';\nimport { isNodeEnvironment } from '../utils';\nimport { LazySuspenseContext } from './context';\n\n/**\n * This component implements a multi step system in order to be consumed on SSR\n * and still allow hydration and render a suspense boundary without having React\n * throw away the SSR content or complaining that the html code does not match.\n *\n * Most of the behaciour is implemented by communicating via context with the\n * lazy child. The lazy component is indeed responsible of collecting its own\n * SSR output and let this suspense alternative render it as fallback.\n *\n * To be clear, it does not render Suspense on the server: it only renders\n * a context provider in order to pass the fallback down to the child being\n * rendered if the lazy component is not there.\n *\n * Then on the client, during hydration, it renders the same provider with\n * two children: the first is the real Suspense component, that renders\n * the lazy child, catching any promise being thrown and wait; the second\n * is the hydration compliant component: it maintains SSR content until\n * the suspended promise is resolved.\n *\n * So during this step, if there is SSR content Suspense renders null and\n * the hydration fallback is rendered as sibling. If not, the lazy child\n * will signal to render the fallback prop, removing the hydration fallback.\n *\n * Once the suspended promise is resolved, Suspense will remove its own\n * fallback but will also tell LazySuspense to get rid of the hydration one.\n *\n */\nexport class LazySuspense extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // Used on server to render fallback down the tree\n      fallback: this.props.fallback,\n      // Used on client to replace fallback with magic input\n      setFallback: fallback => {\n        if (this.hydrationFallback === fallback) return;\n        this.hydrationFallback = fallback; // Schedule an update so we force switch from the sibling tree\n        // back to the suspense boundary\n\n        if (this.mounted) this.forceUpdate();\n      }\n    };\n    this.hydrationFallback = null;\n    this.mounted = false;\n    this.DynamicFallback = ({\n      children,\n      outsideSuspense\n    }) => {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useLayoutEffect(() => {\n        return () => {\n          // the effect cleanup is called by the Suspense boundary itself\n          // when both Lazy AND the eventual promises thrown are done\n          // so Suspense will re-render with actual content and we remove\n          // the hydration fallback at the same time\n          if (!outsideSuspense) this.state.setFallback(null);\n        };\n      }, [outsideSuspense]);\n      return outsideSuspense ? children(this.hydrationFallback ? this.hydrationFallback : null) : children(this.hydrationFallback ? null : this.props.fallback);\n    };\n    this.DynamicFallback.displayName = 'DynamicFallback';\n  }\n  componentDidMount() {\n    this.mounted = true;\n  }\n  renderFallback(outsideSuspense) {\n    const {\n      DynamicFallback\n    } = this; // Use render prop component to allow switch to hydration fallback\n\n    return /*#__PURE__*/React.createElement(DynamicFallback, {\n      outsideSuspense: outsideSuspense\n    }, fallback => fallback);\n  }\n  renderServer() {\n    return /*#__PURE__*/React.createElement(LazySuspenseContext.Provider, {\n      value: this.state\n    }, this.props.children);\n  }\n  renderClient() {\n    return /*#__PURE__*/React.createElement(LazySuspenseContext.Provider, {\n      value: this.state\n    }, /*#__PURE__*/React.createElement(Suspense, {\n      fallback: this.renderFallback(false)\n    }, this.props.children), (!this.mounted || this.hydrationFallback) && this.renderFallback(true));\n  }\n  render() {\n    return isNodeEnvironment() ? this.renderServer() : this.renderClient();\n  }\n}","map":{"version":3,"names":["React","Component","Suspense","useLayoutEffect","isNodeEnvironment","LazySuspenseContext","LazySuspense","constructor","props","state","fallback","setFallback","hydrationFallback","mounted","forceUpdate","DynamicFallback","children","outsideSuspense","displayName","componentDidMount","renderFallback","createElement","renderServer","Provider","value","renderClient","render"],"sources":["../../../src/suspense/component.tsx"],"sourcesContent":["import React, { Component, Suspense, useLayoutEffect } from 'react';\nimport type { FunctionComponent } from 'react';\n\nimport { isNodeEnvironment } from '../utils';\n\nimport { LazySuspenseContext } from './context';\nimport { Fallback, LazySuspenseContextType, LazySuspenseProps } from './types';\n\ntype LazySuspenseState = LazySuspenseContextType;\n\ntype DynamicFallbackProps = {\n  children(fallback: Fallback): any;\n  outsideSuspense: boolean;\n};\n\n/**\n * This component implements a multi step system in order to be consumed on SSR\n * and still allow hydration and render a suspense boundary without having React\n * throw away the SSR content or complaining that the html code does not match.\n *\n * Most of the behaciour is implemented by communicating via context with the\n * lazy child. The lazy component is indeed responsible of collecting its own\n * SSR output and let this suspense alternative render it as fallback.\n *\n * To be clear, it does not render Suspense on the server: it only renders\n * a context provider in order to pass the fallback down to the child being\n * rendered if the lazy component is not there.\n *\n * Then on the client, during hydration, it renders the same provider with\n * two children: the first is the real Suspense component, that renders\n * the lazy child, catching any promise being thrown and wait; the second\n * is the hydration compliant component: it maintains SSR content until\n * the suspended promise is resolved.\n *\n * So during this step, if there is SSR content Suspense renders null and\n * the hydration fallback is rendered as sibling. If not, the lazy child\n * will signal to render the fallback prop, removing the hydration fallback.\n *\n * Once the suspended promise is resolved, Suspense will remove its own\n * fallback but will also tell LazySuspense to get rid of the hydration one.\n *\n */\nexport class LazySuspense extends Component<\n  LazySuspenseProps,\n  LazySuspenseState\n> {\n  state = {\n    // Used on server to render fallback down the tree\n    fallback: this.props.fallback,\n    // Used on client to replace fallback with magic input\n    setFallback: (fallback: Fallback) => {\n      if (this.hydrationFallback === fallback) return;\n      this.hydrationFallback = fallback;\n      // Schedule an update so we force switch from the sibling tree\n      // back to the suspense boundary\n      if (this.mounted) this.forceUpdate();\n    },\n  };\n\n  private hydrationFallback: Fallback = null;\n  private mounted = false;\n\n  constructor(props: LazySuspenseProps) {\n    super(props);\n    this.DynamicFallback.displayName = 'DynamicFallback';\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n  }\n\n  private DynamicFallback: FunctionComponent<DynamicFallbackProps> = ({\n    children,\n    outsideSuspense,\n  }) => {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useLayoutEffect(() => {\n      return () => {\n        // the effect cleanup is called by the Suspense boundary itself\n        // when both Lazy AND the eventual promises thrown are done\n        // so Suspense will re-render with actual content and we remove\n        // the hydration fallback at the same time\n        if (!outsideSuspense) this.state.setFallback(null);\n      };\n    }, [outsideSuspense]);\n\n    return outsideSuspense\n      ? children(this.hydrationFallback ? this.hydrationFallback : null)\n      : children(this.hydrationFallback ? null : this.props.fallback);\n  };\n\n  private renderFallback(outsideSuspense: boolean) {\n    const { DynamicFallback } = this;\n\n    // Use render prop component to allow switch to hydration fallback\n    return (\n      <DynamicFallback outsideSuspense={outsideSuspense}>\n        {(fallback: Fallback) => fallback}\n      </DynamicFallback>\n    );\n  }\n\n  private renderServer() {\n    return (\n      <LazySuspenseContext.Provider value={this.state}>\n        {this.props.children}\n      </LazySuspenseContext.Provider>\n    );\n  }\n\n  private renderClient() {\n    return (\n      <LazySuspenseContext.Provider value={this.state}>\n        <Suspense fallback={this.renderFallback(false)}>\n          {this.props.children}\n        </Suspense>\n        {(!this.mounted || this.hydrationFallback) && this.renderFallback(true)}\n      </LazySuspenseContext.Provider>\n    );\n  }\n\n  render() {\n    return isNodeEnvironment() ? this.renderServer() : this.renderClient();\n  }\n}\n"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,EAAqCC,eAArC,QAA4D,OAA5D;AAGA,SAASC,iBAAT,QAAkC,UAAlC;AAEA,SAASC,mBAAT,QAAoC,WAApC;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,YAAN,SAA2BL,SAA3B,CAGL;EAiBAM,WAAWA,CAACC,KAAD,EAA2B;IACpC,MAAMA,KAAN;IADoC,KAhBtCC,KAgBsC,GAhB9B;MACN;MACAC,QAAQ,EAAE,KAAKF,KAAL,CAAWE,QAFf;MAGN;MACAC,WAAW,EAAGD,QAAD,IAAwB;QACnC,IAAI,KAAKE,iBAAL,KAA2BF,QAA/B,EAAyC;QACzC,KAAKE,iBAAL,GAAyBF,QAAzB,CAFmC,CAGnC;QACA;;QACA,IAAI,KAAKG,OAAT,EAAkB,KAAKC,WAAL;MACnB;IAVK,CAgB8B;IAAA,KAH9BF,iBAG8B,GAHA,IAGA;IAAA,KAF9BC,OAE8B,GAFpB,KAEoB;IAAA,KAS9BE,eAT8B,GAS6B,CAAC;MAClEC,QADkE;MAElEC;IAFkE,CAAD,KAG7D;MACJ;MACAd,eAAe,CAAC,MAAM;QACpB,OAAO,MAAM;UACX;UACA;UACA;UACA;UACA,IAAI,CAACc,eAAL,EAAsB,KAAKR,KAAL,CAAWE,WAAX,CAAuB,IAAvB;QACvB,CAND;MAOD,CARc,EAQZ,CAACM,eAAD,CARY,CAAf;MAUA,OAAOA,eAAe,GAClBD,QAAQ,CAAC,KAAKJ,iBAAL,GAAyB,KAAKA,iBAA9B,GAAkD,IAAnD,CADU,GAElBI,QAAQ,CAAC,KAAKJ,iBAAL,GAAyB,IAAzB,GAAgC,KAAKJ,KAAL,CAAWE,QAA5C,CAFZ;IAGD,CA3BqC;IAEpC,KAAKK,eAAL,CAAqBG,WAArB,GAAmC,iBAAnC;EACD;EAEDC,iBAAiBA,CAAA,EAAG;IAClB,KAAKN,OAAL,GAAe,IAAf;EACD;EAsBOO,cAAcA,CAACH,eAAD,EAA2B;IAC/C,MAAM;MAAEF;IAAF,IAAsB,IAA5B,CAD+C,CAG/C;;IACA,oBACEf,KAAA,CAAAqB,aAAA,CAACN,eAAD;MAAiBE,eAAe,EAAEA;IAAlC,GACIP,QAAD,IAAwBA,QAD3B,CADF;EAKD;EAEOY,YAAYA,CAAA,EAAG;IACrB,oBACEtB,KAAA,CAAAqB,aAAA,CAAChB,mBAAD,CAAqBkB,QAArB;MAA8BC,KAAK,EAAE,KAAKf;IAA1C,GACG,KAAKD,KAAL,CAAWQ,QADd,CADF;EAKD;EAEOS,YAAYA,CAAA,EAAG;IACrB,oBACEzB,KAAA,CAAAqB,aAAA,CAAChB,mBAAD,CAAqBkB,QAArB;MAA8BC,KAAK,EAAE,KAAKf;IAA1C,gBACET,KAAA,CAAAqB,aAAA,CAACnB,QAAD;MAAUQ,QAAQ,EAAE,KAAKU,cAAL,CAAoB,KAApB;IAApB,GACG,KAAKZ,KAAL,CAAWQ,QADd,CADF,EAIG,CAAC,CAAC,KAAKH,OAAN,IAAiB,KAAKD,iBAAvB,KAA6C,KAAKQ,cAAL,CAAoB,IAApB,CAJhD,CADF;EAQD;EAEDM,MAAMA,CAAA,EAAG;IACP,OAAOtB,iBAAiB,KAAK,KAAKkB,YAAL,EAAL,GAA2B,KAAKG,YAAL,EAAnD;EACD;AA9ED"},"metadata":{},"sourceType":"module"}