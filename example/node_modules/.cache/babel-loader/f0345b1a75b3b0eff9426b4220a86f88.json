{"ast":null,"code":"import React, { Children, createContext, memo, useContext, useMemo, useRef } from 'react';\nimport { isReducedMotion } from '../utils/accessibility';\nimport { useForceRender } from '../utils/use-force-render';\n\n/**\n * Internally we will be playing with an element that will always have a key defined.\n */\n\n/**\n * Internal data passed to child motions.\n */\n\n// We define empty context here so the object doesn't change.\nvar emptyContext = {\n  // Motions will always appear if not inside a exiting persistence component.\n  appear: true,\n  isExiting: false\n};\nvar ExitingContext = /*#__PURE__*/createContext(emptyContext);\nvar isAnyPreviousKeysMissingFromCurrent = function isAnyPreviousKeysMissingFromCurrent(currentMap, previous) {\n  for (var i = 0; i < previous.length; i++) {\n    var element = previous[i];\n    var _key = element.key;\n    if (!currentMap[_key]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * This method will wrap any React element with a context provider. We're using context (instead of\n * cloneElement) so we can communicate between multiple elements without the need of prop drilling\n * (results in a better API for consumers).\n */\nvar wrapChildWithContextProvider = function wrapChildWithContextProvider(child) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyContext;\n  return /*#__PURE__*/React.createElement(ExitingContext.Provider, {\n    key: \"\".concat(child.key, \"-provider\"),\n    value: value\n  }, child);\n};\nvar childrenToObj = function childrenToObj(children) {\n  return children.reduce(function (acc, child) {\n    acc[child.key] = child;\n    return acc;\n  }, {});\n};\nvar spliceNewElementsIntoPrevious = function spliceNewElementsIntoPrevious(current, previous) {\n  var splicedChildren = previous.concat([]);\n  var previousMap = childrenToObj(previous);\n  for (var i = 0; i < current.length; i++) {\n    var child = current[i];\n    var childIsNew = !previousMap[child.key];\n    if (childIsNew) {\n      // This will insert the new element after the previous element.\n      splicedChildren.splice(i + 1, 0, child);\n    }\n  }\n  return splicedChildren;\n};\n\n/**\n * This function will convert all children types to an array while also filtering out non-valid React elements.\n */\nvar childrenToArray = function childrenToArray(children) {\n  var childrenAsArray = [];\n\n  // We convert children to an array using this helper method as it will add keys to children that do not\n  // have them, such as when we have hardcoded children that are conditionally rendered.\n  Children.toArray(children).forEach(function (child) {\n    // We ignore any boolean children to make our code a little more simple later on,\n    // and also filter out any falsies (empty strings, nulls, and undefined).\n    if (typeof child !== 'boolean' && Boolean(child)) {\n      // Children WILL have a key after being forced into an array using the React.Children helper.\n      childrenAsArray.push(child);\n    }\n  });\n  return childrenAsArray;\n};\n\n/**\n * This handles the case when a render updates during an exit motion.\n * If any child is mounted again we removed them from the exiting children object and return true.\n */\nvar hasAnyExitingChildMountedAgain = function hasAnyExitingChildMountedAgain(exitingChildren, children) {\n  var exitingChildMountedAgain = false;\n  children.forEach(function (child) {\n    if (exitingChildren.current[child.key]) {\n      exitingChildMountedAgain = true;\n      delete exitingChildren.current[child.key];\n    }\n  });\n  return exitingChildMountedAgain;\n};\n\n/**\n * __ExitingPersistence__\n *\n * Useful for enabling elements to persist and animate away when they are removed from the DOM.\n *\n * - [Examples](https://atlaskit.atlassian.com/packages/design-system/motion/docs/entering-motions)\n */\nvar ExitingPersistence = /*#__PURE__*/memo(function (_ref) {\n  var _ref$appear = _ref.appear,\n    appearFromProp = _ref$appear === void 0 ? false : _ref$appear,\n    childs = _ref.children,\n    exitThenEnter = _ref.exitThenEnter;\n  var children = childrenToArray(childs);\n  var childrenObj = childrenToObj(children);\n  var previousChildren = useRef([]);\n  var persistedChildren = useRef([]);\n  var forceRender = useForceRender();\n  var exitingChildren = useRef({});\n  var appear = useRef(appearFromProp);\n  var defaultContextValue = useMemo(function () {\n    return {\n      appear: appear.current,\n      isExiting: false\n    };\n  },\n  // React rules of hooks says this isn't needed because mutating appear won't cause a re-render.\n  // While technically true - it will trigger this to make a new object on the _next_ render which is what we want.\n  // Remove this or use appear instead of appear.current and you will notice a test breaks.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [appear.current]);\n  if (isReducedMotion()) {\n    return children;\n  }\n  if (!appear.current) {\n    // We always want child motions to appear after the initial mount.\n    appear.current = true;\n  }\n\n  // This entire block can't be an effect because we need it to run synchronously during a render\n  // else when elements are being removed they will be remounted instead of being updated.\n  if (previousChildren.current.length && isAnyPreviousKeysMissingFromCurrent(childrenObj, previousChildren.current)) {\n    if (persistedChildren.current.length === 0 || hasAnyExitingChildMountedAgain(exitingChildren, children)) {\n      persistedChildren.current = previousChildren.current;\n    }\n\n    // We have persisted children now set from previous children.\n    // Let's update previous children so we have it available next render.\n    previousChildren.current = children;\n    return (exitThenEnter ? persistedChildren.current : spliceNewElementsIntoPrevious(children, persistedChildren.current)).map(function (child) {\n      // eslint-disable-next-line @repo/internal/react/no-children-properties-access\n      var currentChild = childrenObj[child.key];\n      if (!currentChild) {\n        // We've found an exiting child - mark it!\n        exitingChildren.current[child.key] = true;\n        return wrapChildWithContextProvider(child, {\n          isExiting: true,\n          appear: true,\n          onFinish: function onFinish() {\n            delete exitingChildren.current[child.key];\n\n            // We will only remove the exiting elements when any subsequent exiting elements have also finished.\n            // Think of removing many items from a todo list - when removing a few over a few clicks we don't\n            // want the list jumping around when they exit.\n            if (Object.keys(exitingChildren.current).length === 0) {\n              // Set previous children to nothing.\n              // This let's us skip the next render check as it's assumed children and previous will be the same.\n              previousChildren.current = [];\n              persistedChildren.current = [];\n\n              // Re-render after the element(s) have animated away which will end up rendering the latest children.\n              forceRender();\n            }\n          }\n        });\n      }\n\n      // This element isn't exiting.\n      // Wrap context and let's continue on our way.\n      return wrapChildWithContextProvider(currentChild, defaultContextValue);\n    });\n  } else {\n    previousChildren.current = children;\n  }\n  return children.map(function (child) {\n    return wrapChildWithContextProvider(child, defaultContextValue);\n  });\n});\nexport var useExitingPersistence = function useExitingPersistence() {\n  return useContext(ExitingContext);\n};\nExitingPersistence.displayName = 'ExitingPersistence';\nexport default ExitingPersistence;","map":{"version":3,"names":["React","Children","createContext","memo","useContext","useMemo","useRef","isReducedMotion","useForceRender","emptyContext","appear","isExiting","ExitingContext","isAnyPreviousKeysMissingFromCurrent","currentMap","previous","i","length","element","_key","key","wrapChildWithContextProvider","child","value","arguments","undefined","createElement","Provider","concat","childrenToObj","children","reduce","acc","spliceNewElementsIntoPrevious","current","splicedChildren","previousMap","childIsNew","splice","childrenToArray","childrenAsArray","toArray","forEach","Boolean","push","hasAnyExitingChildMountedAgain","exitingChildren","exitingChildMountedAgain","ExitingPersistence","_ref","_ref$appear","appearFromProp","childs","exitThenEnter","childrenObj","previousChildren","persistedChildren","forceRender","defaultContextValue","map","currentChild","onFinish","Object","keys","useExitingPersistence","displayName"],"sources":["/home/enterpi/Documents/iidm/pixel-kit/node_modules/@atlaskit/motion/dist/esm/entering/exiting-persistence.js"],"sourcesContent":["import React, { Children, createContext, memo, useContext, useMemo, useRef } from 'react';\nimport { isReducedMotion } from '../utils/accessibility';\nimport { useForceRender } from '../utils/use-force-render';\n\n/**\n * Internally we will be playing with an element that will always have a key defined.\n */\n\n/**\n * Internal data passed to child motions.\n */\n\n// We define empty context here so the object doesn't change.\nvar emptyContext = {\n  // Motions will always appear if not inside a exiting persistence component.\n  appear: true,\n  isExiting: false\n};\nvar ExitingContext = /*#__PURE__*/createContext(emptyContext);\nvar isAnyPreviousKeysMissingFromCurrent = function isAnyPreviousKeysMissingFromCurrent(currentMap, previous) {\n  for (var i = 0; i < previous.length; i++) {\n    var element = previous[i];\n    var _key = element.key;\n    if (!currentMap[_key]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * This method will wrap any React element with a context provider. We're using context (instead of\n * cloneElement) so we can communicate between multiple elements without the need of prop drilling\n * (results in a better API for consumers).\n */\nvar wrapChildWithContextProvider = function wrapChildWithContextProvider(child) {\n  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyContext;\n  return /*#__PURE__*/React.createElement(ExitingContext.Provider, {\n    key: \"\".concat(child.key, \"-provider\"),\n    value: value\n  }, child);\n};\nvar childrenToObj = function childrenToObj(children) {\n  return children.reduce(function (acc, child) {\n    acc[child.key] = child;\n    return acc;\n  }, {});\n};\nvar spliceNewElementsIntoPrevious = function spliceNewElementsIntoPrevious(current, previous) {\n  var splicedChildren = previous.concat([]);\n  var previousMap = childrenToObj(previous);\n  for (var i = 0; i < current.length; i++) {\n    var child = current[i];\n    var childIsNew = !previousMap[child.key];\n    if (childIsNew) {\n      // This will insert the new element after the previous element.\n      splicedChildren.splice(i + 1, 0, child);\n    }\n  }\n  return splicedChildren;\n};\n\n/**\n * This function will convert all children types to an array while also filtering out non-valid React elements.\n */\nvar childrenToArray = function childrenToArray(children) {\n  var childrenAsArray = [];\n\n  // We convert children to an array using this helper method as it will add keys to children that do not\n  // have them, such as when we have hardcoded children that are conditionally rendered.\n  Children.toArray(children).forEach(function (child) {\n    // We ignore any boolean children to make our code a little more simple later on,\n    // and also filter out any falsies (empty strings, nulls, and undefined).\n    if (typeof child !== 'boolean' && Boolean(child)) {\n      // Children WILL have a key after being forced into an array using the React.Children helper.\n      childrenAsArray.push(child);\n    }\n  });\n  return childrenAsArray;\n};\n\n/**\n * This handles the case when a render updates during an exit motion.\n * If any child is mounted again we removed them from the exiting children object and return true.\n */\nvar hasAnyExitingChildMountedAgain = function hasAnyExitingChildMountedAgain(exitingChildren, children) {\n  var exitingChildMountedAgain = false;\n  children.forEach(function (child) {\n    if (exitingChildren.current[child.key]) {\n      exitingChildMountedAgain = true;\n      delete exitingChildren.current[child.key];\n    }\n  });\n  return exitingChildMountedAgain;\n};\n\n/**\n * __ExitingPersistence__\n *\n * Useful for enabling elements to persist and animate away when they are removed from the DOM.\n *\n * - [Examples](https://atlaskit.atlassian.com/packages/design-system/motion/docs/entering-motions)\n */\nvar ExitingPersistence = /*#__PURE__*/memo(function (_ref) {\n  var _ref$appear = _ref.appear,\n    appearFromProp = _ref$appear === void 0 ? false : _ref$appear,\n    childs = _ref.children,\n    exitThenEnter = _ref.exitThenEnter;\n  var children = childrenToArray(childs);\n  var childrenObj = childrenToObj(children);\n  var previousChildren = useRef([]);\n  var persistedChildren = useRef([]);\n  var forceRender = useForceRender();\n  var exitingChildren = useRef({});\n  var appear = useRef(appearFromProp);\n  var defaultContextValue = useMemo(function () {\n    return {\n      appear: appear.current,\n      isExiting: false\n    };\n  },\n  // React rules of hooks says this isn't needed because mutating appear won't cause a re-render.\n  // While technically true - it will trigger this to make a new object on the _next_ render which is what we want.\n  // Remove this or use appear instead of appear.current and you will notice a test breaks.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [appear.current]);\n  if (isReducedMotion()) {\n    return children;\n  }\n  if (!appear.current) {\n    // We always want child motions to appear after the initial mount.\n    appear.current = true;\n  }\n\n  // This entire block can't be an effect because we need it to run synchronously during a render\n  // else when elements are being removed they will be remounted instead of being updated.\n  if (previousChildren.current.length && isAnyPreviousKeysMissingFromCurrent(childrenObj, previousChildren.current)) {\n    if (persistedChildren.current.length === 0 || hasAnyExitingChildMountedAgain(exitingChildren, children)) {\n      persistedChildren.current = previousChildren.current;\n    }\n\n    // We have persisted children now set from previous children.\n    // Let's update previous children so we have it available next render.\n    previousChildren.current = children;\n    return (exitThenEnter ? persistedChildren.current : spliceNewElementsIntoPrevious(children, persistedChildren.current)).map(function (child) {\n      // eslint-disable-next-line @repo/internal/react/no-children-properties-access\n      var currentChild = childrenObj[child.key];\n      if (!currentChild) {\n        // We've found an exiting child - mark it!\n        exitingChildren.current[child.key] = true;\n        return wrapChildWithContextProvider(child, {\n          isExiting: true,\n          appear: true,\n          onFinish: function onFinish() {\n            delete exitingChildren.current[child.key];\n\n            // We will only remove the exiting elements when any subsequent exiting elements have also finished.\n            // Think of removing many items from a todo list - when removing a few over a few clicks we don't\n            // want the list jumping around when they exit.\n            if (Object.keys(exitingChildren.current).length === 0) {\n              // Set previous children to nothing.\n              // This let's us skip the next render check as it's assumed children and previous will be the same.\n              previousChildren.current = [];\n              persistedChildren.current = [];\n\n              // Re-render after the element(s) have animated away which will end up rendering the latest children.\n              forceRender();\n            }\n          }\n        });\n      }\n\n      // This element isn't exiting.\n      // Wrap context and let's continue on our way.\n      return wrapChildWithContextProvider(currentChild, defaultContextValue);\n    });\n  } else {\n    previousChildren.current = children;\n  }\n  return children.map(function (child) {\n    return wrapChildWithContextProvider(child, defaultContextValue);\n  });\n});\nexport var useExitingPersistence = function useExitingPersistence() {\n  return useContext(ExitingContext);\n};\nExitingPersistence.displayName = 'ExitingPersistence';\nexport default ExitingPersistence;"],"mappings":"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"},"metadata":{},"sourceType":"module"}