{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useEffect } from 'react';\nimport useLazyCallback from '@atlaskit/ds-lib/use-lazy-callback';\nimport usePreviousValue from '@atlaskit/ds-lib/use-previous-value';\nimport useStateRef from '@atlaskit/ds-lib/use-state-ref';\nimport { useExitingPersistence } from '@atlaskit/motion/exiting-persistence';\n\n/**\n *  ________________________________________________\n * | MAJOR VERSIONS WILL NOT KNOW ABOUT EACH OTHER! |\n *  ------------------------------------------------\n *\n * An array which holds references to all currently open modal dialogs.\n * This will only work for modal dialogs of the same major version,\n * as the reference will be different between them.\n *\n * E.g. V11 won't know about any from V12.\n */\nvar modalStackRegister = [];\n/**\n * Returns the position of the calling modal dialog in the modal dialog stack.\n * Stack index of `0` is the highest position in the stack,\n * with every higher number being behind in the stack.\n */\nexport default function useModalStack(_ref) {\n  var onStackChange = _ref.onStackChange;\n  var _useExitingPersistenc = useExitingPersistence(),\n    isExiting = _useExitingPersistenc.isExiting;\n  var _useStateRef = useStateRef(0),\n    _useStateRef2 = _slicedToArray(_useStateRef, 2),\n    stackIndexRef = _useStateRef2[0],\n    setStackIndex = _useStateRef2[1];\n  var currentStackIndex = stackIndexRef.current;\n  var previousStackIndex = usePreviousValue(stackIndexRef.current);\n\n  // We want to ensure this function **never changes** during the lifecycle of this component.\n  // This is why it's assigned to a ref and not in a useMemo/useCallback.\n  var updateStack = useLazyCallback(function () {\n    var newStackIndex = modalStackRegister.indexOf(updateStack);\n\n    // We access the stack index ref instead of state because this closure will always only\n    // have the initial state and not any of the later values.\n    if (stackIndexRef.current !== newStackIndex) {\n      setStackIndex(newStackIndex);\n      stackIndexRef.current = newStackIndex;\n    }\n  });\n  useEffect(function () {\n    var currentStackIndex = modalStackRegister.indexOf(updateStack);\n    if (!isExiting && currentStackIndex === -1) {\n      // We are opening the modal dialog.\n      // Add ourselves to the modal stack register!\n      modalStackRegister.unshift(updateStack);\n    }\n    if (isExiting && currentStackIndex !== -1) {\n      // We are closing the modal dialog using a wrapping modal transition component.\n      // Remove ourselves from the modal stack register!\n      // NOTE: Modal dialogs that don't have a wrapping modal transition component won't flow through here!\n      // For that scenario we cleanup when the component unmounts.\n      modalStackRegister.splice(currentStackIndex, 1);\n    }\n\n    // Fire all registered modal dialogs to update their position in the stack.\n    modalStackRegister.forEach(function (cb) {\n      return cb();\n    });\n  }, [updateStack, isExiting]);\n  useEffect(function () {\n    return function () {\n      // Final cleanup just in case this modal dialog did not have a wrapping modal transition.\n      var currentStackIndex = modalStackRegister.indexOf(updateStack);\n      if (currentStackIndex !== -1) {\n        modalStackRegister.splice(currentStackIndex, 1);\n        modalStackRegister.forEach(function (cb) {\n          return cb();\n        });\n      }\n    };\n  }, [updateStack]);\n  useEffect(function () {\n    if (previousStackIndex === undefined) {\n      // Initial case that we don't need to notify about.\n      return;\n    }\n    if (previousStackIndex !== currentStackIndex) {\n      onStackChange(currentStackIndex);\n    }\n  }, [onStackChange, previousStackIndex, currentStackIndex]);\n  return currentStackIndex;\n}","map":{"version":3,"names":["_slicedToArray","useEffect","useLazyCallback","usePreviousValue","useStateRef","useExitingPersistence","modalStackRegister","useModalStack","_ref","onStackChange","_useExitingPersistenc","isExiting","_useStateRef","_useStateRef2","stackIndexRef","setStackIndex","currentStackIndex","current","previousStackIndex","updateStack","newStackIndex","indexOf","unshift","splice","forEach","cb","undefined"],"sources":["/home/enterpi/Documents/iidm/pixel-kit/node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-modal-stack.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useEffect } from 'react';\nimport useLazyCallback from '@atlaskit/ds-lib/use-lazy-callback';\nimport usePreviousValue from '@atlaskit/ds-lib/use-previous-value';\nimport useStateRef from '@atlaskit/ds-lib/use-state-ref';\nimport { useExitingPersistence } from '@atlaskit/motion/exiting-persistence';\n\n/**\n *  ________________________________________________\n * | MAJOR VERSIONS WILL NOT KNOW ABOUT EACH OTHER! |\n *  ------------------------------------------------\n *\n * An array which holds references to all currently open modal dialogs.\n * This will only work for modal dialogs of the same major version,\n * as the reference will be different between them.\n *\n * E.g. V11 won't know about any from V12.\n */\nvar modalStackRegister = [];\n/**\n * Returns the position of the calling modal dialog in the modal dialog stack.\n * Stack index of `0` is the highest position in the stack,\n * with every higher number being behind in the stack.\n */\nexport default function useModalStack(_ref) {\n  var onStackChange = _ref.onStackChange;\n  var _useExitingPersistenc = useExitingPersistence(),\n    isExiting = _useExitingPersistenc.isExiting;\n  var _useStateRef = useStateRef(0),\n    _useStateRef2 = _slicedToArray(_useStateRef, 2),\n    stackIndexRef = _useStateRef2[0],\n    setStackIndex = _useStateRef2[1];\n  var currentStackIndex = stackIndexRef.current;\n  var previousStackIndex = usePreviousValue(stackIndexRef.current);\n\n  // We want to ensure this function **never changes** during the lifecycle of this component.\n  // This is why it's assigned to a ref and not in a useMemo/useCallback.\n  var updateStack = useLazyCallback(function () {\n    var newStackIndex = modalStackRegister.indexOf(updateStack);\n\n    // We access the stack index ref instead of state because this closure will always only\n    // have the initial state and not any of the later values.\n    if (stackIndexRef.current !== newStackIndex) {\n      setStackIndex(newStackIndex);\n      stackIndexRef.current = newStackIndex;\n    }\n  });\n  useEffect(function () {\n    var currentStackIndex = modalStackRegister.indexOf(updateStack);\n    if (!isExiting && currentStackIndex === -1) {\n      // We are opening the modal dialog.\n      // Add ourselves to the modal stack register!\n      modalStackRegister.unshift(updateStack);\n    }\n    if (isExiting && currentStackIndex !== -1) {\n      // We are closing the modal dialog using a wrapping modal transition component.\n      // Remove ourselves from the modal stack register!\n      // NOTE: Modal dialogs that don't have a wrapping modal transition component won't flow through here!\n      // For that scenario we cleanup when the component unmounts.\n      modalStackRegister.splice(currentStackIndex, 1);\n    }\n\n    // Fire all registered modal dialogs to update their position in the stack.\n    modalStackRegister.forEach(function (cb) {\n      return cb();\n    });\n  }, [updateStack, isExiting]);\n  useEffect(function () {\n    return function () {\n      // Final cleanup just in case this modal dialog did not have a wrapping modal transition.\n      var currentStackIndex = modalStackRegister.indexOf(updateStack);\n      if (currentStackIndex !== -1) {\n        modalStackRegister.splice(currentStackIndex, 1);\n        modalStackRegister.forEach(function (cb) {\n          return cb();\n        });\n      }\n    };\n  }, [updateStack]);\n  useEffect(function () {\n    if (previousStackIndex === undefined) {\n      // Initial case that we don't need to notify about.\n      return;\n    }\n    if (previousStackIndex !== currentStackIndex) {\n      onStackChange(currentStackIndex);\n    }\n  }, [onStackChange, previousStackIndex, currentStackIndex]);\n  return currentStackIndex;\n}"],"mappings":"AAAA,OAAOA,cAAc,MAAM,sCAAsC;AACjE,SAASC,SAAS,QAAQ,OAAO;AACjC,OAAOC,eAAe,MAAM,oCAAoC;AAChE,OAAOC,gBAAgB,MAAM,qCAAqC;AAClE,OAAOC,WAAW,MAAM,gCAAgC;AACxD,SAASC,qBAAqB,QAAQ,sCAAsC;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,kBAAkB,GAAG,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,aAAaA,CAACC,IAAI,EAAE;EAC1C,IAAIC,aAAa,GAAGD,IAAI,CAACC,aAAa;EACtC,IAAIC,qBAAqB,GAAGL,qBAAqB,CAAC,CAAC;IACjDM,SAAS,GAAGD,qBAAqB,CAACC,SAAS;EAC7C,IAAIC,YAAY,GAAGR,WAAW,CAAC,CAAC,CAAC;IAC/BS,aAAa,GAAGb,cAAc,CAACY,YAAY,EAAE,CAAC,CAAC;IAC/CE,aAAa,GAAGD,aAAa,CAAC,CAAC,CAAC;IAChCE,aAAa,GAAGF,aAAa,CAAC,CAAC,CAAC;EAClC,IAAIG,iBAAiB,GAAGF,aAAa,CAACG,OAAO;EAC7C,IAAIC,kBAAkB,GAAGf,gBAAgB,CAACW,aAAa,CAACG,OAAO,CAAC;;EAEhE;EACA;EACA,IAAIE,WAAW,GAAGjB,eAAe,CAAC,YAAY;IAC5C,IAAIkB,aAAa,GAAGd,kBAAkB,CAACe,OAAO,CAACF,WAAW,CAAC;;IAE3D;IACA;IACA,IAAIL,aAAa,CAACG,OAAO,KAAKG,aAAa,EAAE;MAC3CL,aAAa,CAACK,aAAa,CAAC;MAC5BN,aAAa,CAACG,OAAO,GAAGG,aAAa;IACvC;EACF,CAAC,CAAC;EACFnB,SAAS,CAAC,YAAY;IACpB,IAAIe,iBAAiB,GAAGV,kBAAkB,CAACe,OAAO,CAACF,WAAW,CAAC;IAC/D,IAAI,CAACR,SAAS,IAAIK,iBAAiB,KAAK,CAAC,CAAC,EAAE;MAC1C;MACA;MACAV,kBAAkB,CAACgB,OAAO,CAACH,WAAW,CAAC;IACzC;IACA,IAAIR,SAAS,IAAIK,iBAAiB,KAAK,CAAC,CAAC,EAAE;MACzC;MACA;MACA;MACA;MACAV,kBAAkB,CAACiB,MAAM,CAACP,iBAAiB,EAAE,CAAC,CAAC;IACjD;;IAEA;IACAV,kBAAkB,CAACkB,OAAO,CAAC,UAAUC,EAAE,EAAE;MACvC,OAAOA,EAAE,CAAC,CAAC;IACb,CAAC,CAAC;EACJ,CAAC,EAAE,CAACN,WAAW,EAAER,SAAS,CAAC,CAAC;EAC5BV,SAAS,CAAC,YAAY;IACpB,OAAO,YAAY;MACjB;MACA,IAAIe,iBAAiB,GAAGV,kBAAkB,CAACe,OAAO,CAACF,WAAW,CAAC;MAC/D,IAAIH,iBAAiB,KAAK,CAAC,CAAC,EAAE;QAC5BV,kBAAkB,CAACiB,MAAM,CAACP,iBAAiB,EAAE,CAAC,CAAC;QAC/CV,kBAAkB,CAACkB,OAAO,CAAC,UAAUC,EAAE,EAAE;UACvC,OAAOA,EAAE,CAAC,CAAC;QACb,CAAC,CAAC;MACJ;IACF,CAAC;EACH,CAAC,EAAE,CAACN,WAAW,CAAC,CAAC;EACjBlB,SAAS,CAAC,YAAY;IACpB,IAAIiB,kBAAkB,KAAKQ,SAAS,EAAE;MACpC;MACA;IACF;IACA,IAAIR,kBAAkB,KAAKF,iBAAiB,EAAE;MAC5CP,aAAa,CAACO,iBAAiB,CAAC;IAClC;EACF,CAAC,EAAE,CAACP,aAAa,EAAES,kBAAkB,EAAEF,iBAAiB,CAAC,CAAC;EAC1D,OAAOA,iBAAiB;AAC1B"},"metadata":{},"sourceType":"module"}