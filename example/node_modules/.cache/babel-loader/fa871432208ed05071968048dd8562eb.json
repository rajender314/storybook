{"ast":null,"code":"import React, { lazy, useContext, useMemo, useState } from 'react';\nimport { getConfig, MODE } from '../../config';\nimport { COLLECTED, PHASE } from '../../constants';\nimport { WaitContext } from '../../lazy-wait';\nimport { LazyPhaseContext } from '../../phase';\nimport { LazySuspenseContext } from '../../suspense';\nimport { PRIORITY } from '../constants';\nimport { createLoaderError } from '../errors';\nimport { PlaceholderFallbackRender } from '../placeholders/render';\nimport { PlaceholderFallbackHydrate } from '../placeholders/hydrate';\nimport { preloadAsset } from '../preload';\nimport { ProfilerContext } from '../../profiler';\nimport { useSubscription } from './utils'; // @ts-expect-error requestIdleCallback might not exist\n\nconst {\n  requestIdleCallback = setTimeout\n} = window;\nexport function createComponentClient({\n  defer,\n  deferred,\n  dataLazyId,\n  moduleId\n}) {\n  const ResolvedLazy = /*#__PURE__*/lazy(() => deferred.promise);\n  return props => {\n    // use a single piece of state to hold info about progress or eventually\n    // throw an error. We do change it via direct mutation as re-renders\n    // break Suspense in React 18, making it lose hydration state\n    const [status, bubbleError] = useState(() => ({\n      noWait: undefined,\n      phase: defer === PHASE.AFTER_PAINT ? false : true,\n      preloaded: defer === PHASE.AFTER_PAINT ? false : true,\n      started: false\n    }));\n    const profiler = useContext(ProfilerContext).current;\n    const load = () => {\n      if (status.started || !status.phase || !status.noWait) {\n        return;\n      }\n      status.started = true;\n      let onResolve;\n      if (profiler) {\n        const eventInfo = {\n          identifier: moduleId\n        };\n        onResolve = () => {\n          profiler.onLoadComplete(eventInfo);\n        };\n        profiler.onLoadStart(eventInfo);\n      }\n      const result = deferred.start().catch(err => {\n        // Throw the error within the component lifecycle\n        // refer to https://github.com/facebook/react/issues/11409\n        bubbleError(() => {\n          throw createLoaderError(err);\n        });\n      });\n      if (onResolve) {\n        result.then(onResolve);\n      }\n    }; // Subscribe to LazyWait context, triggering load when until is true\n\n    useSubscription({\n      context: WaitContext,\n      load,\n      onValue: v => status.noWait = v === 1\n    });\n    if (defer === PHASE.AFTER_PAINT) {\n      // Subscribe to LazyPhase context, triggering load when own phase starts\n      useSubscription({\n        context: LazyPhaseContext,\n        load,\n        onValue: v => status.phase = v >= defer\n      }); // Schedule preloading as will be needed soon\n\n      useMemo(() => {\n        if (!status.preloaded) {\n          status.preloaded = true;\n          requestIdleCallback(() => {\n            if (status.started) return;\n            preloadAsset({\n              loader: deferred.preload,\n              moduleId,\n              priority: PRIORITY.LOW\n            });\n          });\n        }\n      }, [status]);\n    }\n    const {\n      setFallback\n    } = useContext(LazySuspenseContext);\n    useMemo(() => {\n      // find SSR content (or fallbacks) wrapped in inputs based on lazyId\n      const content = (COLLECTED.get(dataLazyId) || []).shift();\n      if (!content) return; // override Suspense fallback with magic input wrappers\n\n      const component = getConfig().mode === MODE.RENDER ? /*#__PURE__*/React.createElement(PlaceholderFallbackRender, {\n        id: dataLazyId,\n        content: content\n      }) : /*#__PURE__*/React.createElement(PlaceholderFallbackHydrate, {\n        id: dataLazyId,\n        content: content\n      });\n      setFallback(component);\n    }, [setFallback]);\n    return /*#__PURE__*/React.createElement(ResolvedLazy, props);\n  };\n}","map":{"version":3,"names":["React","lazy","useContext","useMemo","useState","getConfig","MODE","COLLECTED","PHASE","WaitContext","LazyPhaseContext","LazySuspenseContext","PRIORITY","createLoaderError","PlaceholderFallbackRender","PlaceholderFallbackHydrate","preloadAsset","ProfilerContext","useSubscription","requestIdleCallback","setTimeout","window","createComponentClient","defer","deferred","dataLazyId","moduleId","ResolvedLazy","promise","props","status","bubbleError","noWait","undefined","phase","AFTER_PAINT","preloaded","started","profiler","current","load","onResolve","eventInfo","identifier","onLoadComplete","onLoadStart","result","start","catch","err","then","context","onValue","v","loader","preload","priority","LOW","setFallback","content","get","shift","component","mode","RENDER","createElement","id"],"sources":["../../../../src/lazy/components/client.tsx"],"sourcesContent":["import React, { lazy, useContext, useMemo, useState } from 'react';\nimport type { ComponentProps, ComponentType } from 'react';\n\nimport { getConfig, MODE } from '../../config';\nimport { COLLECTED, PHASE } from '../../constants';\nimport { WaitContext } from '../../lazy-wait';\nimport { LazyPhaseContext } from '../../phase';\nimport { LazySuspenseContext } from '../../suspense';\n\nimport { PRIORITY } from '../constants';\nimport { Deferred } from '../deferred';\nimport { createLoaderError } from '../errors';\nimport { PlaceholderFallbackRender } from '../placeholders/render';\nimport { PlaceholderFallbackHydrate } from '../placeholders/hydrate';\nimport { preloadAsset } from '../preload';\nimport { ProfilerContext } from '../../profiler';\n\nimport type { Status } from './types';\nimport { useSubscription } from './utils';\n\n// @ts-expect-error requestIdleCallback might not exist\nconst { requestIdleCallback = setTimeout } = window;\n\nexport function createComponentClient<C extends ComponentType<any>>({\n  defer,\n  deferred,\n  dataLazyId,\n  moduleId,\n}: {\n  defer: number;\n  deferred: Deferred<C>;\n  dataLazyId: string;\n  moduleId: string;\n}) {\n  const ResolvedLazy = lazy(() => deferred.promise);\n\n  return (props: ComponentProps<C>) => {\n    // use a single piece of state to hold info about progress or eventually\n    // throw an error. We do change it via direct mutation as re-renders\n    // break Suspense in React 18, making it lose hydration state\n    const [status, bubbleError] = useState<Status>(() => ({\n      noWait: undefined,\n      phase: defer === PHASE.AFTER_PAINT ? false : true,\n      preloaded: defer === PHASE.AFTER_PAINT ? false : true,\n      started: false,\n    }));\n\n    const profiler = useContext(ProfilerContext).current;\n\n    const load = () => {\n      if (status.started || !status.phase || !status.noWait) {\n        return;\n      }\n\n      status.started = true;\n      let onResolve;\n      if (profiler) {\n        const eventInfo = { identifier: moduleId };\n        onResolve = () => {\n          profiler.onLoadComplete(eventInfo);\n        };\n        profiler.onLoadStart(eventInfo);\n      }\n\n      const result = deferred.start().catch((err: Error) => {\n        // Throw the error within the component lifecycle\n        // refer to https://github.com/facebook/react/issues/11409\n        bubbleError(() => {\n          throw createLoaderError(err);\n        });\n      });\n\n      if (onResolve) {\n        result.then(onResolve);\n      }\n    };\n\n    // Subscribe to LazyWait context, triggering load when until is true\n    useSubscription({\n      context: WaitContext,\n      load,\n      onValue: v => (status.noWait = v === 1),\n    });\n\n    if (defer === PHASE.AFTER_PAINT) {\n      // Subscribe to LazyPhase context, triggering load when own phase starts\n      useSubscription({\n        context: LazyPhaseContext,\n        load,\n        onValue: v => (status.phase = v >= defer),\n      });\n\n      // Schedule preloading as will be needed soon\n      useMemo(() => {\n        if (!status.preloaded) {\n          status.preloaded = true;\n          requestIdleCallback(() => {\n            if (status.started) return;\n            preloadAsset({\n              loader: deferred.preload,\n              moduleId,\n              priority: PRIORITY.LOW,\n            });\n          });\n        }\n      }, [status]);\n    }\n\n    const { setFallback } = useContext(LazySuspenseContext);\n\n    useMemo(() => {\n      // find SSR content (or fallbacks) wrapped in inputs based on lazyId\n      const content = (COLLECTED.get(dataLazyId) || []).shift();\n      if (!content) return;\n\n      // override Suspense fallback with magic input wrappers\n      const component =\n        getConfig().mode === MODE.RENDER ? (\n          <PlaceholderFallbackRender id={dataLazyId} content={content} />\n        ) : (\n          <PlaceholderFallbackHydrate id={dataLazyId} content={content} />\n        );\n      setFallback(component);\n    }, [setFallback]);\n\n    return <ResolvedLazy {...props} />;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}