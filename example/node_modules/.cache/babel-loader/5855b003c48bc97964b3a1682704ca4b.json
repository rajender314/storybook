{"ast":null,"code":"import { isValid, normalizeDate, toDate } from './utils';\nimport { normalizeLocale } from '../common';\nvar INVALID_DATE = new Date(NaN);\nvar INVARIANT = {\n  year: 1993,\n  month: 2,\n  day: 18\n};\nvar INVARIANT_DATE = toDate(INVARIANT);\nvar FORMAT_EXTRACTOR_REGEX = /(\\d+)[^\\d]+(\\d+)[^\\d]+(\\d+)\\.?/;\nvar DATE_PARSER_REGEX = /(\\d+)[^\\d]*(\\d+)?[^\\d]*(\\d+)?\\.?/;\n\n// Internet Explorer returns non-printing characters when formatting a date\nvar stripExtras = function stripExtras(str) {\n  return str.replace(/\\u200E/g, '');\n};\nvar extractDateParts = function extractDateParts(matchResult) {\n  return matchResult\n  // Get the 3 capture groups\n  .splice(1, 4)\n  // Convert them to numbers\n  .map(function (datePart) {\n    return parseInt(datePart, 10);\n  });\n};\n/**\n * Creates a date parser function for a specific locale. The function will\n * either return a valid Date from the input or an Invalid Date object if the\n * input is invalid.\n *\n * @param locale - A BCP 47 language tag\n * @returns DateParser\n */\nexport var createDateParser = function createDateParser(locale) {\n  // Intl.DateFormat expects locales in the format of 'la-CO' however it is\n  // common for locale to be provided in the format of 'la_CO', where 'la' is\n  // language and 'CO' is country.\n  var normalizedLocale = normalizeLocale(locale);\n  var dateFormatter = Intl.DateTimeFormat(normalizedLocale);\n\n  // Generate a date string from a hard coded date, this allows us to determine\n  // the year/month/day position for the provided locale.\n  var rawDateString = dateFormatter.format(INVARIANT_DATE);\n  var shortDate = stripExtras(rawDateString);\n\n  // Extract the date pieces from the locale formatted date string\n  var formatMatch = shortDate.match(FORMAT_EXTRACTOR_REGEX);\n  if (!formatMatch) {\n    throw new Error('Unable to create DateParser');\n  }\n  var formatParts = extractDateParts(formatMatch);\n\n  // Find the year/month/day positions of the locale formatted invariant date\n  var yearPosition = formatParts.indexOf(INVARIANT.year);\n  var monthPosition = formatParts.indexOf(INVARIANT.month);\n  var dayPosition = formatParts.indexOf(INVARIANT.day);\n  return function (date) {\n    var dateMatch = stripExtras(date).match(DATE_PARSER_REGEX);\n    if (!dateMatch) {\n      return INVALID_DATE;\n    }\n    var dateParts = extractDateParts(dateMatch);\n\n    // Use the previously extracted year/month/day positions to extract each\n    // date piece.\n    var extractedDate = {\n      year: dateParts[yearPosition],\n      month: dateParts[monthPosition],\n      day: dateParts[dayPosition]\n    };\n    var normalizedDate = normalizeDate(extractedDate);\n    if (!isValid(normalizedDate)) {\n      return INVALID_DATE;\n    }\n    return toDate(normalizedDate);\n  };\n};","map":{"version":3,"names":["isValid","normalizeDate","toDate","normalizeLocale","INVALID_DATE","Date","NaN","INVARIANT","year","month","day","INVARIANT_DATE","FORMAT_EXTRACTOR_REGEX","DATE_PARSER_REGEX","stripExtras","str","replace","extractDateParts","matchResult","splice","map","datePart","parseInt","createDateParser","locale","normalizedLocale","dateFormatter","Intl","DateTimeFormat","rawDateString","format","shortDate","formatMatch","match","Error","formatParts","yearPosition","indexOf","monthPosition","dayPosition","date","dateMatch","dateParts","extractedDate","normalizedDate"],"sources":["/home/enterpi/Documents/iidm/pixel-kit/node_modules/@atlaskit/locale/dist/esm/internal/date-parser/index.js"],"sourcesContent":["import { isValid, normalizeDate, toDate } from './utils';\nimport { normalizeLocale } from '../common';\nvar INVALID_DATE = new Date(NaN);\nvar INVARIANT = {\n  year: 1993,\n  month: 2,\n  day: 18\n};\nvar INVARIANT_DATE = toDate(INVARIANT);\nvar FORMAT_EXTRACTOR_REGEX = /(\\d+)[^\\d]+(\\d+)[^\\d]+(\\d+)\\.?/;\nvar DATE_PARSER_REGEX = /(\\d+)[^\\d]*(\\d+)?[^\\d]*(\\d+)?\\.?/;\n\n// Internet Explorer returns non-printing characters when formatting a date\nvar stripExtras = function stripExtras(str) {\n  return str.replace(/\\u200E/g, '');\n};\nvar extractDateParts = function extractDateParts(matchResult) {\n  return matchResult\n  // Get the 3 capture groups\n  .splice(1, 4)\n  // Convert them to numbers\n  .map(function (datePart) {\n    return parseInt(datePart, 10);\n  });\n};\n/**\n * Creates a date parser function for a specific locale. The function will\n * either return a valid Date from the input or an Invalid Date object if the\n * input is invalid.\n *\n * @param locale - A BCP 47 language tag\n * @returns DateParser\n */\nexport var createDateParser = function createDateParser(locale) {\n  // Intl.DateFormat expects locales in the format of 'la-CO' however it is\n  // common for locale to be provided in the format of 'la_CO', where 'la' is\n  // language and 'CO' is country.\n  var normalizedLocale = normalizeLocale(locale);\n  var dateFormatter = Intl.DateTimeFormat(normalizedLocale);\n\n  // Generate a date string from a hard coded date, this allows us to determine\n  // the year/month/day position for the provided locale.\n  var rawDateString = dateFormatter.format(INVARIANT_DATE);\n  var shortDate = stripExtras(rawDateString);\n\n  // Extract the date pieces from the locale formatted date string\n  var formatMatch = shortDate.match(FORMAT_EXTRACTOR_REGEX);\n  if (!formatMatch) {\n    throw new Error('Unable to create DateParser');\n  }\n  var formatParts = extractDateParts(formatMatch);\n\n  // Find the year/month/day positions of the locale formatted invariant date\n  var yearPosition = formatParts.indexOf(INVARIANT.year);\n  var monthPosition = formatParts.indexOf(INVARIANT.month);\n  var dayPosition = formatParts.indexOf(INVARIANT.day);\n  return function (date) {\n    var dateMatch = stripExtras(date).match(DATE_PARSER_REGEX);\n    if (!dateMatch) {\n      return INVALID_DATE;\n    }\n    var dateParts = extractDateParts(dateMatch);\n\n    // Use the previously extracted year/month/day positions to extract each\n    // date piece.\n    var extractedDate = {\n      year: dateParts[yearPosition],\n      month: dateParts[monthPosition],\n      day: dateParts[dayPosition]\n    };\n    var normalizedDate = normalizeDate(extractedDate);\n    if (!isValid(normalizedDate)) {\n      return INVALID_DATE;\n    }\n    return toDate(normalizedDate);\n  };\n};"],"mappings":"AAAA,SAASA,OAAO,EAAEC,aAAa,EAAEC,MAAM,QAAQ,SAAS;AACxD,SAASC,eAAe,QAAQ,WAAW;AAC3C,IAAIC,YAAY,GAAG,IAAIC,IAAI,CAACC,GAAG,CAAC;AAChC,IAAIC,SAAS,GAAG;EACdC,IAAI,EAAE,IAAI;EACVC,KAAK,EAAE,CAAC;EACRC,GAAG,EAAE;AACP,CAAC;AACD,IAAIC,cAAc,GAAGT,MAAM,CAACK,SAAS,CAAC;AACtC,IAAIK,sBAAsB,GAAG,gCAAgC;AAC7D,IAAIC,iBAAiB,GAAG,kCAAkC;;AAE1D;AACA,IAAIC,WAAW,GAAG,SAASA,WAAWA,CAACC,GAAG,EAAE;EAC1C,OAAOA,GAAG,CAACC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC;AACnC,CAAC;AACD,IAAIC,gBAAgB,GAAG,SAASA,gBAAgBA,CAACC,WAAW,EAAE;EAC5D,OAAOA;EACP;EAAA,CACCC,MAAM,CAAC,CAAC,EAAE,CAAC;EACZ;EAAA,CACCC,GAAG,CAAC,UAAUC,QAAQ,EAAE;IACvB,OAAOC,QAAQ,CAACD,QAAQ,EAAE,EAAE,CAAC;EAC/B,CAAC,CAAC;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIE,gBAAgB,GAAG,SAASA,gBAAgBA,CAACC,MAAM,EAAE;EAC9D;EACA;EACA;EACA,IAAIC,gBAAgB,GAAGtB,eAAe,CAACqB,MAAM,CAAC;EAC9C,IAAIE,aAAa,GAAGC,IAAI,CAACC,cAAc,CAACH,gBAAgB,CAAC;;EAEzD;EACA;EACA,IAAII,aAAa,GAAGH,aAAa,CAACI,MAAM,CAACnB,cAAc,CAAC;EACxD,IAAIoB,SAAS,GAAGjB,WAAW,CAACe,aAAa,CAAC;;EAE1C;EACA,IAAIG,WAAW,GAAGD,SAAS,CAACE,KAAK,CAACrB,sBAAsB,CAAC;EACzD,IAAI,CAACoB,WAAW,EAAE;IAChB,MAAM,IAAIE,KAAK,CAAC,6BAA6B,CAAC;EAChD;EACA,IAAIC,WAAW,GAAGlB,gBAAgB,CAACe,WAAW,CAAC;;EAE/C;EACA,IAAII,YAAY,GAAGD,WAAW,CAACE,OAAO,CAAC9B,SAAS,CAACC,IAAI,CAAC;EACtD,IAAI8B,aAAa,GAAGH,WAAW,CAACE,OAAO,CAAC9B,SAAS,CAACE,KAAK,CAAC;EACxD,IAAI8B,WAAW,GAAGJ,WAAW,CAACE,OAAO,CAAC9B,SAAS,CAACG,GAAG,CAAC;EACpD,OAAO,UAAU8B,IAAI,EAAE;IACrB,IAAIC,SAAS,GAAG3B,WAAW,CAAC0B,IAAI,CAAC,CAACP,KAAK,CAACpB,iBAAiB,CAAC;IAC1D,IAAI,CAAC4B,SAAS,EAAE;MACd,OAAOrC,YAAY;IACrB;IACA,IAAIsC,SAAS,GAAGzB,gBAAgB,CAACwB,SAAS,CAAC;;IAE3C;IACA;IACA,IAAIE,aAAa,GAAG;MAClBnC,IAAI,EAAEkC,SAAS,CAACN,YAAY,CAAC;MAC7B3B,KAAK,EAAEiC,SAAS,CAACJ,aAAa,CAAC;MAC/B5B,GAAG,EAAEgC,SAAS,CAACH,WAAW;IAC5B,CAAC;IACD,IAAIK,cAAc,GAAG3C,aAAa,CAAC0C,aAAa,CAAC;IACjD,IAAI,CAAC3C,OAAO,CAAC4C,cAAc,CAAC,EAAE;MAC5B,OAAOxC,YAAY;IACrB;IACA,OAAOF,MAAM,CAAC0C,cAAc,CAAC;EAC/B,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"module"}