{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { normalizeLocale } from '../common';\nimport { createDateParser } from '../date-parser';\nimport { toFormattedParts } from './toFormattedParts';\nexport var createLocalizationProvider = function createLocalizationProvider(locale, formatterOptions) {\n  // Intl.DateFormat expects locales in the format of 'la-CO' however it is\n  // common for locale to be provided in the format of 'la_CO', where 'la' is\n  // language and 'CO' is country.\n  var normalizedLocale = normalizeLocale(locale);\n  var formatDate = function formatDate(date) {\n    return Intl.DateTimeFormat(normalizedLocale).format(date);\n  };\n  var formatTime = function formatTime(date) {\n    return Intl.DateTimeFormat(normalizedLocale, {\n      hour: 'numeric',\n      minute: 'numeric'\n    }).format(date);\n  };\n  var getDays = function getDays() {\n    var weekStartDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var length = arguments.length > 1 ? arguments[1] : undefined;\n    var dayFormatter = Intl.DateTimeFormat(normalizedLocale, {\n      weekday: length\n    });\n\n    // Right now there is no way to find out first day of the week based on Intl (locale)\n    // api. Check issue here: https://github.com/tc39/ecma402/issues/6\n    // So we rotate the weekdays based on #weekStartDay parameter.\n    var weekdays = [0, 1, 2, 3, 4, 5, 6];\n    var rotatedWeekdays = weekStartDay > 0 ? [].concat(_toConsumableArray(weekdays.slice(weekStartDay)), _toConsumableArray(weekdays.slice(0, weekStartDay))) : weekdays;\n    return rotatedWeekdays.map(function (day) {\n      // Some short days are longer than 3 characters but are unique if the first\n      // three non-white characters are used.\n      var result = dayFormatter\n      // Date range chosen which has a Sun-Sat range so we can extract the names\n      .format(new Date(2000, 9, day + 1, 12))\n      // \\u200E matches on the Left-to-Right Mark character in IE/Edge\n      .replace(/[\\s\\u200E]/g, '');\n\n      // If short days, only return first three characters. Else return whole thing\n      if (length === 'short') {\n        return result.substring(0, 3);\n      } else {\n        return result;\n      }\n    });\n  };\n  var getDaysShort = function getDaysShort() {\n    var weekStartDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return getDays(weekStartDay, 'short');\n  };\n  var getDaysLong = function getDaysLong() {\n    var weekStartDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return getDays(weekStartDay, 'long');\n  };\n  var getMonthsLong = function getMonthsLong() {\n    var monthFormatter = Intl.DateTimeFormat(normalizedLocale, {\n      month: 'long'\n    });\n    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(function (month) {\n      return (\n        // Date chosen for no real reason, the only important part is the month\n        // Using 2020 'cos Safari has a faulty implementation when we use the year 2000\n        // Intl.DateTimeFormat(\"en-US\", { month: 'long'}).format(new Date(2000, 3, 1))\n        // should give \"April\" but gives \"March\" in Safari\n        monthFormatter.format(new Date(2020, month, 1))\n      );\n    });\n  };\n  var parseDate = function parseDate(date) {\n    return createDateParser(normalizedLocale)(date);\n  };\n  var formatToParts = function formatToParts() {\n    var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n    var formatter = new Intl.DateTimeFormat(normalizedLocale, formatterOptions);\n    /**\n     * Safari has a bug that returns the wrong month for years 2005 and before.\n     * The error occurs when the passed date has been created with numbers, like new Date(2000, 3, 1)\n     * Not all the months fail in each year. To ensure the correct output,\n     * we select 2020 as the base year for the whole date,\n     * then we replace in the result the original input year\n     */\n    var fixedDate = new Date(date);\n    fixedDate.setFullYear(2020);\n    var fixedParts = toFormattedParts(formatter.formatToParts(fixedDate));\n    var originalParts = toFormattedParts(formatter.formatToParts(date));\n    if (fixedParts.year) {\n      fixedParts.year = originalParts.year;\n    }\n\n    /**\n     * Chrome has a bug that returns hour=\"00\" when it's 12:00pm in certain languages\n     * We fix it by detecting the real time with getHours method\n     */\n    if (fixedParts.hour === '00' && fixedDate.getHours() === 12) {\n      fixedParts.hour = '12';\n    }\n    return fixedParts;\n  };\n  return {\n    getDaysShort: getDaysShort,\n    getDaysLong: getDaysLong,\n    getMonthsLong: getMonthsLong,\n    formatDate: formatDate,\n    formatTime: formatTime,\n    parseDate: parseDate,\n    formatToParts: formatToParts\n  };\n};","map":{"version":3,"names":["_toConsumableArray","normalizeLocale","createDateParser","toFormattedParts","createLocalizationProvider","locale","formatterOptions","normalizedLocale","formatDate","date","Intl","DateTimeFormat","format","formatTime","hour","minute","getDays","weekStartDay","arguments","length","undefined","dayFormatter","weekday","weekdays","rotatedWeekdays","concat","slice","map","day","result","Date","replace","substring","getDaysShort","getDaysLong","getMonthsLong","monthFormatter","month","parseDate","formatToParts","formatter","fixedDate","setFullYear","fixedParts","originalParts","year","getHours"],"sources":["/home/enterpi/Documents/iidm/pixel-kit/node_modules/@atlaskit/locale/dist/esm/internal/localization-provider/localization-provider.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { normalizeLocale } from '../common';\nimport { createDateParser } from '../date-parser';\nimport { toFormattedParts } from './toFormattedParts';\nexport var createLocalizationProvider = function createLocalizationProvider(locale, formatterOptions) {\n  // Intl.DateFormat expects locales in the format of 'la-CO' however it is\n  // common for locale to be provided in the format of 'la_CO', where 'la' is\n  // language and 'CO' is country.\n  var normalizedLocale = normalizeLocale(locale);\n  var formatDate = function formatDate(date) {\n    return Intl.DateTimeFormat(normalizedLocale).format(date);\n  };\n  var formatTime = function formatTime(date) {\n    return Intl.DateTimeFormat(normalizedLocale, {\n      hour: 'numeric',\n      minute: 'numeric'\n    }).format(date);\n  };\n  var getDays = function getDays() {\n    var weekStartDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var length = arguments.length > 1 ? arguments[1] : undefined;\n    var dayFormatter = Intl.DateTimeFormat(normalizedLocale, {\n      weekday: length\n    });\n\n    // Right now there is no way to find out first day of the week based on Intl (locale)\n    // api. Check issue here: https://github.com/tc39/ecma402/issues/6\n    // So we rotate the weekdays based on #weekStartDay parameter.\n    var weekdays = [0, 1, 2, 3, 4, 5, 6];\n    var rotatedWeekdays = weekStartDay > 0 ? [].concat(_toConsumableArray(weekdays.slice(weekStartDay)), _toConsumableArray(weekdays.slice(0, weekStartDay))) : weekdays;\n    return rotatedWeekdays.map(function (day) {\n      // Some short days are longer than 3 characters but are unique if the first\n      // three non-white characters are used.\n      var result = dayFormatter\n      // Date range chosen which has a Sun-Sat range so we can extract the names\n      .format(new Date(2000, 9, day + 1, 12))\n      // \\u200E matches on the Left-to-Right Mark character in IE/Edge\n      .replace(/[\\s\\u200E]/g, '');\n\n      // If short days, only return first three characters. Else return whole thing\n      if (length === 'short') {\n        return result.substring(0, 3);\n      } else {\n        return result;\n      }\n    });\n  };\n  var getDaysShort = function getDaysShort() {\n    var weekStartDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return getDays(weekStartDay, 'short');\n  };\n  var getDaysLong = function getDaysLong() {\n    var weekStartDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return getDays(weekStartDay, 'long');\n  };\n  var getMonthsLong = function getMonthsLong() {\n    var monthFormatter = Intl.DateTimeFormat(normalizedLocale, {\n      month: 'long'\n    });\n    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(function (month) {\n      return (\n        // Date chosen for no real reason, the only important part is the month\n        // Using 2020 'cos Safari has a faulty implementation when we use the year 2000\n        // Intl.DateTimeFormat(\"en-US\", { month: 'long'}).format(new Date(2000, 3, 1))\n        // should give \"April\" but gives \"March\" in Safari\n        monthFormatter.format(new Date(2020, month, 1))\n      );\n    });\n  };\n  var parseDate = function parseDate(date) {\n    return createDateParser(normalizedLocale)(date);\n  };\n  var formatToParts = function formatToParts() {\n    var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n    var formatter = new Intl.DateTimeFormat(normalizedLocale, formatterOptions);\n    /**\n     * Safari has a bug that returns the wrong month for years 2005 and before.\n     * The error occurs when the passed date has been created with numbers, like new Date(2000, 3, 1)\n     * Not all the months fail in each year. To ensure the correct output,\n     * we select 2020 as the base year for the whole date,\n     * then we replace in the result the original input year\n     */\n    var fixedDate = new Date(date);\n    fixedDate.setFullYear(2020);\n    var fixedParts = toFormattedParts(formatter.formatToParts(fixedDate));\n    var originalParts = toFormattedParts(formatter.formatToParts(date));\n    if (fixedParts.year) {\n      fixedParts.year = originalParts.year;\n    }\n\n    /**\n     * Chrome has a bug that returns hour=\"00\" when it's 12:00pm in certain languages\n     * We fix it by detecting the real time with getHours method\n     */\n    if (fixedParts.hour === '00' && fixedDate.getHours() === 12) {\n      fixedParts.hour = '12';\n    }\n    return fixedParts;\n  };\n  return {\n    getDaysShort: getDaysShort,\n    getDaysLong: getDaysLong,\n    getMonthsLong: getMonthsLong,\n    formatDate: formatDate,\n    formatTime: formatTime,\n    parseDate: parseDate,\n    formatToParts: formatToParts\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}